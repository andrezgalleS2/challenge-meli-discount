# Meli Discount API

 ## Bienvenidos üòÅ

## Descripci√≥n
Esta API REST permite gestionar descuentos exclusivos para vendedores en Mercado Libre, garantizando que solo un √≠tem activo por vendedor tenga el **Meli Discount**. Adem√°s, soporta la segmentaci√≥n de descuentos por categor√≠as tal cual como se requiere en el challenge presentado.

## Dise√±o de arquitectura
![meli discount architecture](https://github.com/user-attachments/assets/3de36c91-6145-425d-9214-ec0ef3eb22ed)

En este dise√±o he querido plasmar como aborde la soluci√≥n desde un concepto macro donde puedo tener una visi√≥n clara de como mi desarrollo debe comportarse y conectarse seg√∫n la l√≥gica de negocio, teniendo conexiones al api externa de mercado libre , autenticando y autorizando la comunicaci√≥n interna de mis endpoints y los scopess de cada sistema.

## Tecnolog√≠as Utilizadas
- **Lenguaje:** Java 17
- **Framework:** Spring Boot
- **Autenticaci√≥n:** JSON Web Tokens (JWT)
- **Integraci√≥n con Mercado Libre:** APIs de Items y Categor√≠as
- **Seguridad:** Implementaci√≥n de autenticaci√≥n y autorizaci√≥n con JWT

## Instalaci√≥n y Ejecuci√≥n

### Prerrequisitos
- Java 17 Coretto (17.0.10)
- Maven
- Intellij Idea

### Instalaci√≥n
```sh
# Clonar el repositorio
$ git clone https://github.com/tu_usuario/meli-discount.git
$ cd meli-discount
```

Luego de clonar nuestro repositorio procederemos abrir el proyecto en Intellij y nos iremos al apartado de project structure.

<img width="1440" alt="image" src="https://github.com/user-attachments/assets/5c745746-550a-473e-b084-dcc4322bc99c" />

En el apartado de project structure veremos directamente la configuraci√≥n del SDK para nuestro proyecto, por favor realizar la siguiente configuraci√≥n para ejecutar el proyecto.

<img width="1440" alt="image" src="https://github.com/user-attachments/assets/4ad9d447-048f-44ed-8f9b-1780b68849b4" />

y como Language level SDK Default

### Ejecuci√≥n

Despu√©s de haber configurado el entorno podremos runear el proyecto directamente desde el archivo *ChallengeMeliDiscountApplication*

<img width="1440" alt="image" src="https://github.com/user-attachments/assets/1b4ce21c-af2c-4743-91e9-75f2a61db4f4" />


El proyecto tendr√° como puerto de hospedaje `http://localhost:8080`.

## Estructura y arquitectura de meli-discount

El proyecto sigue los principios de **Clean Architecture**, asegurando modularidad y separaci√≥n de responsabilidades. La estructura del file system es la siguiente:

<img width="373" alt="image" src="https://github.com/user-attachments/assets/9edea16a-0237-49f2-aed1-16f95bc8ce8a" />

Esto se hace con el fin que a futuro se pueda tener una facilidad de escalar el codigo y trabajar en responsabilidades unicas por personas o equipos.


## üìÇ Archivos de Inter√©s

A continuaci√≥n, se describen algunos de los archivos clave en la implementaci√≥n del proyecto:

### 1Ô∏è‚É£ `Api/Discount/DiscountController.java`
**Responsabilidad:**  
Este controlador maneja los endpoints relacionados con los descuentos de productos en Mercado Libre.  

**Principales funcionalidades:**  
- `GET /api/meli/discount` ‚Üí Obtiene los productos con descuento.
- `GET /api/meli/discount/categories` ‚Üí Obtiene los productos con descuento por categor√≠a.

### 2Ô∏è‚É£ `Api/Token/TokenController.java`
**Responsabilidad:**  
Proporciona un endpoint para la generaci√≥n de tokens JWT necesarios para la autenticaci√≥n.  

**Principales funcionalidades:**  
- `GET /api/token/generate` ‚Üí Genera un token de autenticaci√≥n JWT.

### 3Ô∏è‚É£ `Application/Usescase/Discount/Categories/CategoriesService.java`
**Responsabilidad:**  
Implementa la l√≥gica de negocio para obtener productos categorizados por descuento.

**Principales funcionalidades:**  
- Valida los IDs de los productos.
- Obtiene informaci√≥n de categor√≠as a trav√©s de la API de Mercado Libre.
- Agrupa los productos por categor√≠a y filtra los conjuntos m√°s relevantes.

### 4Ô∏è‚É£ `Application/Usescase/Discount/Items/ItemsService.java`
**Responsabilidad:**  
Encargado de la l√≥gica para obtener productos con descuento.

**Principales funcionalidades:**  
- Agrupa productos por vendedor.
- Filtra productos seg√∫n la mejor combinaci√≥n de descuentos.
- Ordena los productos seg√∫n su fecha de creaci√≥n.

### 5Ô∏è‚É£ `Infrastructure/Adapter/GetCategories/ExternalGetCategoriesPort.java`
**Responsabilidad:**  
Adaptador que interact√∫a con la API externa de Mercado Libre para obtener informaci√≥n de categor√≠as.

**Principales funcionalidades:**  
- Realiza peticiones HTTP a la API de Mercado Libre.
- Incluye autenticaci√≥n con **Bearer Token**.
- Maneja respuestas y errores de la API externa.

Esta estructura modular permite desacoplar la l√≥gica de negocio de la infraestructura y facilita la escalabilidad del proyecto. üöÄ

### 6Ô∏è‚É£ Infrastructure/Jwt

### `JwtTokenFilter.java`
Filtro de seguridad que intercepta solicitudes HTTP para validar la autenticaci√≥n del usuario mediante JWT o autenticaci√≥n b√°sica en ciertos casos.

**Principales funcionalidades:**  
- Si la solicitud es a `/api/token/generate`, se valida con autenticaci√≥n b√°sica (`Basic Auth`).
- Para otras rutas, se requiere un **token JWT v√°lido** en el encabezado `Authorization`.
-  **Manejo de errores**:
- Si el token es inv√°lido o est√° ausente, responde con `401 Unauthorized` y un mensaje JSON descriptivo.

---

### `JwtTokenProvider.java`
Componente responsable de generar tokens JWT para la autenticaci√≥n de usuarios.

**Principales funcionalidades:**  
-  **Firma del Token**: Utiliza `HS256` para garantizar seguridad.
-  **Expiraci√≥n configurable**: El tiempo de validez del token es configurable mediante propiedades.
-  **M√©todo principal**:
- `createToken(String username)`: Genera un JWT v√°lido para el usuario proporcionado.

---

### 7Ô∏è‚É£ Mocks

### `Mocks.java`
Clase de utilidades para generar datos simulados utilizados en pruebas.

**Principales funcionalidades:**  
-  **Generaci√≥n de datos de prueba**:
- `getItemsResponse()`: Retorna una lista simulada de `ItemsResponse` con datos ficticios.
- `getItemsForCategory(String categoryId)`: Simula la estructura de categor√≠as de Mercado Libre.
- **Estructuras din√°micas**:
- Usa m√©todos auxiliares para crear categor√≠as y productos de prueba.

---

### 8Ô∏è‚É£ Utils

### `Utils.java`
Clase de utilidades con funciones auxiliares para la aplicaci√≥n.

**Principales funcionalidades:**  
-  **Conversi√≥n de datos**:
- `convertToJson(T object)`: Convierte un objeto a formato JSON con formato legible.
-  **Validaci√≥n de IDs**:
- `isValidIds(String ids)`: Verifica que los IDs sigan el formato correcto (`MLAxxxx`).
- **Optimizaci√≥n de conjuntos de datos**:
- `getLargestNonOverlappingSet(List<ItemsResponse> items)`: Implementa un algoritmo para encontrar el conjunto m√°s grande de elementos sin solaparse los descuentos.



## Endpoints

### Generar Token
```sh
curl --location 'http://localhost:8080/api/token/generate' \
--header 'Cookie: JSESSIONID=E4BBF30322D98082D2A19C2E937D5F09'
```

### Obtener √çtems con Meli Discount
```sh
curl --location 'http://localhost:8080/api/meli/discount?item_ids=MLA1747839094,MLA1641136702' \
--header 'Authorization: Bearer TU_TOKEN_AQUI'
```

### Obtener Categor√≠as de los √çtems
```sh
curl --location 'http://localhost:8080/api/meli/discount/categories?item_ids=MLA1747839094%2CMLA1641136702' \
--header 'Authorization: Bearer TU_TOKEN_AQUI' \
--header 'Cookie: JSESSIONID=E4BBF30322D98082D2A19C2E937D5F09'
```

## Consideraciones para Escalar el Proyecto a 100k RPM üîù

Para escalar este proyecto a 100k RPM, tendremos que tener las siguientes consideraciones que mejorar√°n el rendimiento para el proyecto y lo preparar√°n para altos niveles de tr√°fico y estr√©s:

### Escenario 1: Escalabilidad Vertical (√∫nica instancia)

Nuestro proyecto podr√° tener una √∫nica instancia y un plan de infraestructura que sea capaz de escalar seg√∫n las reglas de consumo de la m√°quina. Esto permitir√° que, en los picos de consumo, haya un mayor aprovisionamiento de recursos para gestionar la alta demanda. Asimismo, cuando no haya picos de tr√°fico, los recursos podr√°n reducirse para evitar su desperdicio.

#### Consideraciones clave:
1. **Autoescalado (Auto-Scaling)**: 
   - Configurar un sistema de autoescalado para ajustar din√°micamente los recursos (CPU, memoria, etc.) seg√∫n la demanda de tr√°fico. Servicios como **AWS Auto Scaling**, **Azure Scale Sets** o **Google Cloud Auto Scaling** son ideales para este tipo de configuraciones.

2. **Manejo de Picos de Demanda**: 
   - Asegurar que el sistema pueda reaccionar r√°pidamente durante los picos de tr√°fico para garantizar que la infraestructura pueda manejar un mayor n√∫mero de solicitudes sin afectar el rendimiento.

3. **Optimizaci√≥n de Costos**:
   - Implementar estrategias para reducir los recursos durante los periodos de baja demanda, como el uso de instancias de bajo costo (**EC2 Spot Instances**) o ajustar din√°micamente la infraestructura para no desperdiciar recursos cuando la demanda disminuye.

4. **Monitoreo y Alertas**:
   - Implementar un sistema de monitoreo efectivo utilizando herramientas como **Prometheus** y **Grafana**, **AWS CloudWatch** o **Datadog**, para analizar m√©tricas de uso y realizar ajustes autom√°ticos de recursos seg√∫n el comportamiento del sistema.

---

### Escenario 2: Escalabilidad Horizontal (instancias distribuidas)

En este escenario, el sistema se puede distribuir en instancias, como en pods de Kubernetes, lo que permite gestionar mejor los recursos y el tr√°fico. Al multiplicar las instancias del proyecto, se podr√° gestionar el tr√°fico de manera m√°s eficiente, lo que es una opci√≥n viable si el sistema crece y se vuelve m√°s robusto con bases de datos y otros componentes adicionales.

#### Consideraciones clave:
1. **Contenedores y Orquestaci√≥n (Kubernetes)**:
   - Usar **Kubernetes** para distribuir las instancias en contenedores dentro de un cl√∫ster de pods, lo que facilita la gesti√≥n de m√∫ltiples r√©plicas del sistema de forma eficiente. Esto garantizar√≠a una mayor disponibilidad y escalabilidad.

2. **Balanceo de Carga**:
   - Implementar un balanceador de carga para distribuir el tr√°fico de manera equitativa entre todas las instancias del sistema. Soluciones como **NGINX**, **HAProxy** o servicios en la nube como **AWS Elastic Load Balancer (ELB)** o **Google Cloud Load Balancing** son esenciales para este prop√≥sito.

3. **Escalabilidad Autom√°tica**:
   - Configurar el autoescalado para ajustar autom√°ticamente el n√∫mero de r√©plicas seg√∫n el tr√°fico entrante. **Kubernetes Horizontal Pod Autoscaler (HPA)** puede ser utilizado para gestionar la escalabilidad seg√∫n las m√©tricas de carga (como CPU o memoria).

4. **Resiliencia y Recuperaci√≥n Ante Fallos**:
   - Utilizar estrategias de resiliencia como **Pod Disruption Budgets** y **Pod Affinity** en Kubernetes para asegurar la distribuci√≥n adecuada de las instancias y garantizar la alta disponibilidad incluso durante fallos de componentes o recursos.



## Contacto
Si tienes dudas o mejoras, puedes contactarme en `tu.email@dominio.com`.
